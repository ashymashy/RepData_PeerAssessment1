if(x > 3) {}
if (x>3) {
y <-
} else {
if (x>3) {y <- 10} else {y <- 0}
for(i in 1:10){print(i)}
x <- c("a","b","c","d")
for(i in seq_along(x)){print(x[i])}
for(i in 1:4) {
print(x[i])
}
for(letter in x) {
print(letter)
}
z <- 5
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5)
if(coin == 1) {  ## random walk
z <- z + 1
} else {
z <- z - 1
} }
make.power <- function(n) {
]
make.power <- function(n) {
pow <- function(x) {
x^n }
pow }
make.power(2)
cube <- make.power(3)
cube(3)
y <- 10
f <- function(x) {
y <- 2
y^2 + g(x)
}
g <- function(x) { x*y
}
f(3)
x <- list(a = 1:5, b = rnorm(10))
lapply(x,mean)
c <- rnorm(10)
c
x <- matrix(rnorm(2), 2, 2)
x
x <- matrix(1:3, 2, 2)
x <- matrix(a=1:3, 2, 2)
x <- matrix(a=1:2, 2, 2)
x <- matrix(, 2, 2)
x
x <- matrix(c(1,2,3,4), 2, 2)
x
apply(x, 1, sum)
apply(x, 2, sum)
cube <- function(x, n) {
x^3
}
cube(3)
pow <- function(x = 4, n = 3) {
x^n
}
pow()
x <- 1:10
if(x > 5) {
x <- 0
}
debug(ls)
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 12
f(3)
Final Earthquake Analysis
Install.packages("KernSmooth")
install.packages("KernSmooth")
library(KernSmooth)
x <- data.frame(foo = 1:4, bar = c(T, T, F, F))
x
x[1]
x[[1]]
x[2]
x[[1,2]]
x[[1]][[2]]
x[c(1,2)]
x[c(1)]
x[c(1)]>2
x[xc(1)>2,]
x[c(1)>2,]
x[x[c(1)]>2,]
x <- data.frame(foo = 1:4, goo = 2:5 , bar = c(T, T, F, F))
x
x[x[c(2)]>3, ]
install.packages("swirl")  # Installs swirl
library(swirl)  # Loads swirl
swirl()  # Runs swirl
install.packages("swirl")  # Installs swirl
library(swirl)  # Loads swirl
swirl()  # Runs swirl
5 +7
x <- 5 + 7
x
y <- x - 3
y
c(1.1, 9, 3.14)
z <- c(1.1, 9, 3.14)
?c
z
info()
install.packages("KernSmooth")
library(KernSmooth)
getwd
getwd()
getmonitor <- function(id, directory, summarize = FALSE) {
te1 <- formatC(id, width=3, flag="0")
filename = paste(directory, te1, sep = "/")
filename1 = paste(filename, "csv", sep = ".")
test <- read.table(file = filename1, header=T, sep=",")
if(summarize) {
print(summary(test))
return (test)
} else {
return (test)
}
}
getmonitor(22, "~/Projects/specdata")
?source
above <- function(x, n) {
use <- x > n
x[use]
}
above(10,10)
above(10,1)
above(1:8,3)
pollutantmean <- function(directory, pollutant, id) {
director = paste("~/Projects", directory, sep = "/")
id2 <- c(id)
l <- length(id2)
means <- numeric()
pollutant1 <- c("sulfate", "nitrate")
if (pollutant1[1] == pollutant) {
for (i in 1:l) {
te1 <- formatC(id2[i], width=3, flag="0")
filename = paste(director, te1, sep = "/")
filename1 = paste(filename, "csv", sep = ".")
test <- read.csv(file = filename1, header=T, sep=",")
means <- append(means, test[ , 2], after = 0)
}
}
if (pollutant1[2] == pollutant) {
for (i in 1:l) {
te1 <- formatC(id2[i], width=3, flag="0")
filename = paste(director, te1, sep = "/")
filename1 = paste(filename, "csv", sep = ".")
test <- read.csv(file = filename1, header=T, sep=",")
means <- append(means, test[ , 3], after = 0)
}
}
mean(means, na.rm = TRUE)
}
search()
f <- fnunction(x, y) {
x^2 + y / z
}
f <- fnunction(x, y) {
x^2 + y / z }
f <- fnunction(x, y) {x^2 + y / z }
z
x
f(2,3)
f
y <- 10
f <- function {
y <- 2
y^2 + g(x)
}
g <- function(x) {
x*y
}
y <- 10
f <- function {
y <- 2
y^2 + g(x)
}
g <- function(x) {
x*y
}
y <- 10
f <- function(x) {
y <- 2
y^2 + g(x)
}
g <- function(x) {
x*y
}
f(3)
3^10
g <- function(x) {
x*y
}
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
search(h)
search()
x <- 1:4
x[x>5]
x[x>2]
x <- matrix(1:4, 2, 2); y <- matrix(rep(10, 4), 2, 2)
x
y
x * y
x %*% y
x[2]
x$2
?$
x <- Sys.time()
x
p <- asPOSIXlt(x)
p <- as.POSIXlt(x)
p$sec
p[se]
p[sec]
p[[sec]]
x$1
x
x <- 1:3
x$1
p[1,1]
p[[1,1]]
p[1]
p
p$sec
p[1,2]
p[1,1]
x <- list(a = 1:5, b = rnorm(10))
lapply(x, mean)
x
x[1]
x[[1]]
Sum(1:5)
sum(1:5)
x <- 1:4
lapply(x, runif, min = 0, max = 10)
lapply(x, runif, min = 0, max = ...)
lapply(x, runif, min = 0, ...)
x <- list(a = matrix(1:4, 2, 2), b= mareix(1:6, 3, 2))
x <- list(a = matrix(1:4, 2, 2), b= matrix(1:6, 3, 2))
x
lapply(x, function(elt) elt[, 1])
sapply(x, function(elt) elt[, 1])
library(datasets)
data(iris)
?iris
data <- data(iris)
data
data(iris)
data<-iris
data
data[101]
data[[101]]
data[101,]
data[,virginica]
data[,5]
data[ ,6]
data[101:150 ,5]
data[101:150 ,]
mean(data[101:150 ,])
data[101:150 ,1]
mean(data[101:150 ,1])
mean(data[1:150 ,1])
apply(iris[, 1:4], 1, mean)
apply(iris[, 1:4], 2, mean)
?apply
library(datasets)
data(mtcars)
?mtcars
data2 <- mtcars
data2
with(mtcars, tapply(mpg, cyl, mean))
apply(mtcars, 2, mean)
split(mtcars, mtcars$cyl)
sapply(mtcars, cyl, mean)
with(mtcars, tapply(mpg, hp, mean))
with(mtcars, tapply(hp, cyl, mean))
209.21429 - 82.63636
debug(ls)
ls
ls(y~x)
2
4
exit
exit()
bye()
debug(lm)
lm
ls
library(datasets)
data(mtcars)
mean(mtcars$mpg, mtcars$cyl)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
with(mtcars, tapply(mpg, cyl, mean))
#This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
#This function computes the inverse of the special "matrix"
#returned by  makeCacheMatrix  above.
#If the inverse has already been calculated (and the matrix has not changed),
#then  cacheSolve  should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) { #if the mean has already been calculated
message("getting cached data")
return(m) #returned by  makeCacheMatrix  above
}
data <- x$get()
m <- mean(data, ...)
x$setsolve(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setInverse <- function(solve) m <<- solve
getInverse <- function() m
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Computes the inverse of the special "matrix" return by makeCacheMatrix
## If the reverse has been calculated, cacheSolve will retrieve the inverse from cache
## Returns a matrix that is the inverse of 'x'
cacheSolve <- function(x, ...) {
m <- x$getInverse()
if(!is.null(m)) {
message("getting cached data...")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setInverse(m)
m
}
set.seed(1)
rpois(5, 2)
?rpois
?rnorm
?dnorm
?set.seed
?rpois
set.seed(10)
x <- rbinom(10, 10, 0.5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
x
y
y
?rbinom
e
system.time()
?system.time()
summaryRprof(library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL))
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
?set.seed
summaryRprof(lm(y ~ x1 + x2))
set.seed(10)
x1 <- rbinom(10, 10, 0.5)
x2 <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
summaryRprof(lm(y ~ x1 + x2))
summaryRprof(fit<-lm(y ~ x1 + x2))
?summaryRprof
x1 <- 3
x2 <- 5
summaryRprof(lm(y ~ x1 + x2))
?lm
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
x1 <- gl(2, 10, 20, labels = c("Ctl","Trt"))
x2 <- c(ctl, trt)
summaryRprof(lm(y ~ x1 + x2))
summaryRprof(fit<-lm(y ~ x1 + x2))
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
set.seed(10)
x1 <- rbinom(10, 10, 0.5)
x2 <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
summaryRprof()
$by.total
summaryRprof(fit)
summaryRprof(lm(y ~ x1 + x2))
sample.interval
sample.interval=1000
summaryRprof()
?qpois
?fead
?fread
?fread()
install.packages("xlsx")
library(xlsx)
install.packages("xlsx")
library(xlsx)
library(xlsx)
library(httr)
library(jsonlite)
library(XML)
library(RMySQL)
setwd("/Users/iseed/Projects/repdata/RepData_PeerAssessment1")
data <- read.csv(unz("activity.zip", "activity.csv"))
hist(tapply(data$steps, data$date, sum), xlab = "Total daily steps", breaks = 20,
main = "Total of steps taken per day")
total.daily.steps <- as.numeric(tapply(data$steps, data$date, sum))
total.daily.steps
data$interval <- as.factor(as.character(data$interval))
data$interval
data$steps
type(data$steps)
class(data$steps)
levels(data$interval)
as.numeric(levels(data$interval))
?levels
c(steps, data$steps[2])
data$steps[2]
